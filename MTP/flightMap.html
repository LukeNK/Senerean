<!--
    PROCEDURE TO EXPORT THE BASE MAP
    Use MPI/Union-map, adjust everything inside the Aviation layer
    All points (fix/airport) must be put down at circle in the approriate sub-layer
-->
<head>
    <style>
        /* This will be move into the object */
        .airport {
            fill: purple;
        }
        .divToPort{
            /* Divert to airport */
            stroke: lime;
            stroke-opacity: 0.5;
            stroke-width: 200px;
        }
        .divFromPort{
            /* Divert from airport */
            fill: red;
            stroke-width: 0;
        }

        .fix {
            fill: lime;
        }

        .flight {
            fill: limegreen;
            stroke: black;
            stroke-width: 10px;
        }
        .flEI {
            fill: #000080;
            stroke: white;
        }
        .flWH {
            fill: #cb7f49;
            stroke: black;
        }
        .highlight {
            stroke: limegreen;
            stroke-opacity: 0.5;
            stroke-width: 200px;
        }
        .divert {
            fill: red;
            stroke: yellow;
            stroke-opacity: 0.5;
            stroke-width: 200px;
        }
    </style>
    <style>
        /* This will stay here */
        body {
            padding: 0;
            margin: 0;
        }

        div {
            z-index: 6;
            position: fixed;
            display: block;
        }

        button, input {
            outline: 0;
            border: 0;
            background-color: transparent;
        }
    </style>
</head>

<body>
    <div>
        <button onclick="divert()">Divert</button>
        <input type="text" id="divertAirport">
        <p>Flights: <span id="count">0</span> <span id="xInfo"></span></p>
    </div>
    <object id="obj" width="100%" type="image/svg+xml" data="Union-aviation-map.svg"></object>
</body>

<script>
    const Delta = 0.05; // how much a tick represent compare to the unit (per hour)
    const PI = Math.PI,
        sqrt = Math.sqrt,
        sin = Math.sin,
        cos = Math.cos,
        atan2 = Math.atan2,
        abs = Math.abs,
        min = Math.min,
        max = Math.max,
        random = Math.random,
        floor = Math.floor;
        const toRad = x => x * PI / 180,
        toDeg = x => x * 180 / PI;
        const nm = 1.852; // nautical miles factor

        // utils
    const randomItem = arr => arr[floor((random() * arr.length))];
    const randomName = (len, mode) => {
        const letter = 'abcdefghijklmnopqrstuvwxyz',
        num = '0123456789';

        let chars = ''
        if (mode == 'l') chars = letter;
        else if (mode == 'n') chars = num;
        else chars = letter + num;

        let out = ''
        for (let l1 = 0; l1 < len; l1++) out += randomItem(chars);
        return out;
    }

    let canvas = document.getElementById('obj');
    canvas.addEventListener('load', () => {
        canvas = canvas.contentDocument;

        // copy style
        canvas.documentElement.append(document.querySelector('style'))

        // initialize
        for (const fix of canvas.querySelectorAll('circle')) {
            new Fix(
                Number(fix.getAttribute('cx')),
                Number(fix.getAttribute('cy')),
                fix.getAttribute('inkscape:label'),
                fix.parentElement.getAttribute('inkscape:label') == 'Airport'
            )
            fix.remove()
        }

        // permutate the plan
        for (let airline of Object.keys(Flight.plan)) {
            if (['EI', 'WH'].includes(airline)) continue; // skip
            for (let l1 in Fix.airport) {
                let dep = Fix.airport[l1].name;
                if (dep.startsWith(airline))
                    for (let l2 in Fix.airport) {
                        let arv = Fix.airport[l2].name;
                        if (dep == arv) continue;

                        // check if plan existed
                        let existed = false;
                        for (let l3 in Flight.plan[airline])
                            if (
                                Flight.plan[airline][l3].startsWith(dep)
                                && Flight.plan[airline][l3].endsWith(arv)
                            ) {
                                existed = true;
                                break
                            };

                        if (!existed) Flight.plan[airline].push(dep + '-' + arv);
                    }
            }
        }

        // convert and validate plan
        for (let l1 in Flight.plan)
            for (let l2 in Flight.plan[l1]) {
                Flight.plan[l1][l2] = Flight.plan[l1][l2].split('-');
                for (const fix of Flight.plan[l1][l2])
                    if (!(fix in Fix.list)) console.log(fix + ' is invalid')
                // return direction
                Flight.plan[l1].push(Flight.plan[l1][l2].toReversed());
            }
    })

    class Vector {
        #dir = 0;
        get dir() {
            return this.#dir;
        }
        set dir(x) {
            if (x < 0) x = 360 * 10 - abs(x) ; // dumb patch work
            this.#dir = x % 360;
        }
        constructor(length, direction) {
            if (typeof length != "number" || typeof direction != "number")
                throw TypeError('Vector constructor must be a number');
            this.len = length;
            this.dir = direction;
        }
        toPoint() {
            // convert to the next relative points
            // cos theta = (x/l)
            let dir = this.dir, len = this.len;
            return {
                x: cos(toRad(dir)) * len,
                y: sin(toRad(dir)) * len
            }
        }
        static fromPoints(p1, p2) {
            // generate vector from points
            let x = p2.x - p1.x, y = p2.y - p1.y;
            return new Vector(
                sqrt(x*x + y*y),
                toDeg(atan2(y, x))
            );
        }
        copy() {
            return new Vector(this.len, this.dir)
        }
        dirDiff(v2) {
            // difference dir between two vectors
            let d = this.dir - v2.dir; // difference between expected place
            if (abs(d) > 180)
                d = v2.dir - this.dir
            return d;
        }
    }

    class Fix {
        static airport = []
        static list = {}
        constructor(x, y, name, isAirport) {
            this.x = x;
            this.y = y;
            this.name = name || randomName(5).toUpperCase();
            this.isAirport = Boolean(isAirport);

            Fix.list[this.name] = this;
            if (isAirport) {
                Fix.airport.push(this)
                this.elm = canvas.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.elm.setAttribute('cx', x);
                this.elm.setAttribute('cy', y);
                this.elm.setAttribute('r', 100);
            } else {
                this.elm = canvas.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                this.elm.setAttribute('points', `${x},${y-100} ${x+100},${y+100} ${x-100},${y+100}`)
            }
            this.elm.setAttribute('id', this.name);
            this.elm.setAttribute('class', isAirport? 'airport': 'fix');
            this.elm.addEventListener('click', () => {
                for (let l1 in Flight.list) {
                    if (Flight.list[l1].plan.includes(Fix.list[name]))
                        Flight.list[l1].elm.classList.add('highlight')
                }
                document.getElementById('xInfo').innerText = 'Highlighted flights to/via ' + name;
            })

            canvas.documentElement.append(this.elm);
        }
    }

    class Flight {
        static plan = {
            EI: [
                'A0N-EINA',
                'A0E-OLHW2-MIFM-EINA',
                'A0E-OLHW2-OLHW1-EINV',
                'A0W-BLTT-AWN1-EINA',
                'ANE-A0N1-EINA',
                'ANE-OVFK-MIFM-EINV',
                'AWN-AWN1-EINA',
                'AWN-AWN1-EINV',

                'EINA-MIFM',
                'EINA-OVVK',
                'EINA-WHON',
                'EINA-AWN1-BBSJ',
                'EINA-AWN1-BLTT',
                'EINA-SEKAI-EINV',
                'EINA-WHON-A0S',
                'EINA-MIFM-OLHW2-VGJS',
                'EINA-SEKAI-EINV-ESAT',

                'EINV-MIFM',
                'EINV-ESAT',
                'EINV-BAILA-BBSJ',
                'EINV-BAILA-BLTT',
                'EINV-MIFM-OVVK',
                'EINV-MIFM-OVTR',
                'EINV-MOBAI-A0S1-A0S',
                'EINV-OLHW1-OLHW2-VGJS',
                'EINV-OLHW1-OLHW2-VGUG',
            ],
            WH: [
                // 'WHFV',
                // 'WHHN',
                // 'WHJJ',
                // 'WHMB',
                // 'WHON',
                // 'WHSE',

                'WHFV-MOBAI-EINV-A0N',
                'WHHN-SEKAI-A0N1-A0N',
                'WHJJ-MOBAI-EINV-A0N',
                'WHMB-MOBAI-EINV-A0N',
                'WHON-SEKAI-A0N1-A0N',
                'WHSE-SEKAI-A0N1-A0N',
                'WHJJ-FAUNA-BLTT-AWN',
                'WHON-FAUNA-BLTT-AWN',

                'WHFV-EINA',
                'WHHN-EINA',
                'WHJJ-EINA',
                'WHMB-EINA',
                'WHON-EINA',
                'WHSE-EINA',
                'WHFV-MOBAI-EINV',
                'WHHN-MOBAI-EINV',
                'WHJJ-MOBAI-EINV',
                'WHMB-MOBAI-EINV',
                'WHON-MOBAI-EINV',
                'WHSE-MOBAI-EINV',

                'WHFV-MOBAI-ESAT',
                'WHHN-MOBAI-ESAT',
                'WHJJ-MOBAI-ESAT',
                'WHMB-MOBAI-ESAT',
                'WHON-MOBAI-ESAT',
                'WHSE-MOBAI-ESAT',

                'WHFV-FAUNA-BBSJ',
                'WHHN-FAUNA-BBSJ',
                'WHJJ-FAUNA-BBSJ',
                'WHMB-FAUNA-BBSJ',
                'WHON-FAUNA-BBSJ',
                'WHSE-FAUNA-BBSJ',

                'WHFV-FAUNA-BLTT',
                'WHHN-FAUNA-BLTT',
                'WHJJ-FAUNA-BLTT',
                'WHMB-FAUNA-BLTT',
                'WHON-FAUNA-BLTT',
                'WHSE-FAUNA-BLTT',

                'WHFV-KALOU-GJKB',
                'WHHN-GJKR-GJKB',
                'WHJJ-GJKR-GJKB',
                'WHMB-KALOU-GJKB',
                'WHON-GJKR-GJKB',
                'WHSE-GJKR-GJKB',
                'WHFV-GJKR',
                'WHHN-GJKR',
                'WHJJ-GJKR',
                'WHMB-GJKR',
                'WHON-GJKR',
                'WHSE-GJKR',

                'WHFV-YSHL-GNSF',
                'WHHN-GNSF',
                'WHJJ-GNSF',
                'WHMB-YSHL-GNSF',
                'WHON-YSHL-GNSF',
                'WHSE-YSHL-GNSF',

                'WHFV-MOBAI-OVVA',
                'WHHN-MOBAI-OVVA',
                'WHJJ-MOBAI-OVVA',
                'WHMB-MOBAI-OVVA',
                'WHON-MOBAI-OVVA',
                'WHSE-MOBAI-OVVA',
                'WHFV-MOBAI-MIFM-OVTR',
                'WHHN-MOBAI-MIFM-OVTR',
                'WHJJ-MOBAI-MIFM-OVTR',
                'WHMB-MOBAI-MIFM-OVTR',
                'WHON-MOBAI-MIFM-OVTR',
                'WHSE-MOBAI-MIFM-OVTR',
                'WHFV-MOBAI-OLHW1-OVFK',
                'WHHN-MOBAI-OLHW1-OVFK',
                'WHJJ-MOBAI-OLHW1-OVFK',
                'WHMB-MOBAI-OLHW1-OVFK',
                'WHON-MOBAI-OLHW1-OVFK',
                'WHSE-MOBAI-OLHW1-OVFK',
                'WHFV-MOBAI-OLHW1-OVVK',
                'WHHN-MOBAI-OLHW1-OVVK',
                'WHJJ-MOBAI-OLHW1-OVVK',
                'WHMB-MOBAI-OLHW1-OVVK',
                'WHON-MOBAI-OLHW1-OVVK',
                'WHSE-MOBAI-OLHW1-OVVK',

                'WHFV-WHSE-TIHN',
                'WHHN-TIHN',
                'WHJJ-WHSE-TIHN',
                'WHMB-WHSE-TIHN',
                'WHON-WHSE-TIHN',
                'WHSE-TIHN',
                'WHFV-WHSE-TILZ',
                'WHHN-TILZ',
                'WHJJ-WHSE-TILZ',
                'WHMB-WHSE-TILZ',
                'WHON-WHSE-TILZ',
                'WHSE-TILZ',

                'WHFV-VGUG',
                'WHHN-WHMB-VGUG',
                'WHJJ-VGUG',
                'WHMB-VGUG',
                'WHON-WHMB-VGUG',
                'WHSE-WHMB-VGUG',
                'WHFV-VGUG-VGJS',
                'WHHN-WHMB-VGUG-VGJS',
                'WHJJ-VGUG-VGJS',
                'WHMB-VGUG-VGJS',
                'WHON-WHMB-VGUG-VGJS',
                'WHSE-WHMB-VGUG-VGJS',

                'WHFV-YSHL',
                'WHHN-YSHL',
                'WHJJ-YSHL',
                'WHMB-YSHL',
                'WHON-YSHL',
                'WHSE-YSHL',
            ]
        }
        static list = [];
        constructor(plan, speed, airline) {
            this.plan = []
            for (let l1 in plan)
                this.plan.push(Fix.list[plan[l1]]);
            this.speed = speed;
            this.callsign = airline + randomName(4, 'n');
            this.divert = false;

            this.x = this.plan[0].x; this.y = this.plan[0].y;
            this.plan.shift(); // remove depart airport

            Flight.list.push(this);

            this.elm = canvas.createElementNS('http://www.w3.org/2000/svg', 'circle');
            this.elm.setAttribute('id', this.callsign);
            this.elm.setAttribute('class', 'flight fl' + airline);
            this.elm.setAttribute('cx', 0); // this.tick() will deal with it
            this.elm.setAttribute('cy', 0);
            this.elm.setAttribute('r', 50);
            canvas.documentElement.append(this.elm)

            this.tick()
        }
        tick() {
            // move to the next tick
            if (this.divert) {
                // find the closest airport
                this.plan = []; // clear

                let min = Infinity, minName = '';
                for (const airport of Fix.airport) {
                    let vec = Vector.fromPoints(this, airport);
                    if (vec.len < min) {
                        min = vec.len;
                        minName = airport.name;
                    }
                }

                this.divert = false; // turn off the flag to not run the math
                this.plan.push(Fix.list[minName])
                this.elm.classList.add('divert')
            }

            let vec = Vector.fromPoints(this, this.plan[0]);

            if (vec.len < nm) {
                this.plan.shift();
                if (this.plan.length == 0) return true;
                vec = Vector.fromPoints(this, this.plan[0]);
            }

            vec.len = min(this.speed * Delta, vec.len);
            vec = vec.toPoint();
            this.x += vec.x;
            this.y += vec.y;

            this.elm.setAttribute('cx', this.x);
            this.elm.setAttribute('cy', this.y);
        }
    }

    let allowTakeoff = true;

    function divert() {
        let divertAirport = document.getElementById('divertAirport').value;
        divertAirport = divertAirport.split('-');

        // change enroute plan destination
        for (const l1 in Flight.list)
            if (Flight.list[l1].plan.at(-1).name == divertAirport[0]) {
                Flight.list[l1].elm.classList.add('divert')
                Flight.list[l1].divert = true;
            }

        // remove from the list of possible waypoints
        Fix.airport.splice(Fix.airport.indexOf(Fix.list[divertAirport[0]]), 1)

        // change flight plan
        for (const airline in Flight.plan)
            for (const l1 in Flight.plan[airline])
                for (const l2 in Flight.plan[airline][l1])
                    if (Flight.plan[airline][l1][l2] == divertAirport[0])
                        Flight.plan[airline][l1][l2] = divertAirport[1];

        // change airport style
        Fix.list[divertAirport[0]].elm.classList.add('divFromPort');
        Fix.list[divertAirport[1]].elm.classList.add('divToPort');
    }

    let sim = setInterval(() => {
        for (let l1 = 0; l1 < Flight.list.length; l1++) {
            const flight = Flight.list[l1];
            if (flight.plan.length <= 0 || flight.tick()) {
                flight.elm.remove();
                Flight.list.splice(l1, 1);
                l1--
            }
        }

        if (allowTakeoff)
            for (let _ = 0; _ < Fix.airport.length / 10; _++) {
                let airline = randomItem(Object.keys(Flight.plan));
                new Flight(
                    randomItem(Flight.plan[airline]),
                    600 + random() * 300,
                    airline
                );
            }

        if (random() < 0.025)
            randomItem(Flight.list).divert = true;

        document.getElementById('count').innerText = Flight.list.length;
    }, 1000 * Delta);

    // setTimeout(() => {
    //     let inp = document.getElementById('divert')
    //     document.getElementById('divertAirport').value = 'EINV-ESAT'
    //     divert();
    //     document.getElementById('divertAirport').value = 'EINA-BLTT'
    //     divert();
    //     document.getElementById('divertAirport').value = 'SEKAI-ESAT'
    //     divert();
    //     document.getElementById('divertAirport').value = 'AWN1-BLTT'
    //     divert();
    // }, 10000);
</script>