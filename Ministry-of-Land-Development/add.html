<style>
    #out {
        color: white;
        white-space: pre-wrap;
    }
</style>
<body style="background-color: #222;">
    <code id="out">Sorry for such manual tedious way</code>
</body>
<script src="./template.js"></script>
<script src="./registry.js"></script>
<script>
    let EXIT = false; // exit all loop
    while (true) {
        let cur = {...TEMPLATE};
        cur.chunks = []; // change chunk to array instead of hint string
        for (const l1 in TEMPLATE) {
            if (l1 == 'chunks') {
                // get cord and split
                let l = prompt('North West-most block coord');
                let r = prompt('South East-most block coord');
                l = l.replace(' ', '').split(',');
                r = r.replace(' ', '').split(',');
                // convert to number
                l[0] = parseInt(l[0]);
                l[1] = parseInt(l[1]);
                r[0] = parseInt(r[0]);
                r[1] = parseInt(r[1]);
                // add dimension to the build
                cur.dimensions = { x: r[0] - l[0] + 1, z: r[1] - l[1] + 1 }
                cur.nw = { x: l[0], z: l[1]};
                cur.se = { x: r[0], z: r[1]};
                // convert to chunks
                l[0] = Math.floor(l[0] / 16);
                l[1] = Math.floor(l[1] / 16);
                r[0] = Math.floor(r[0] / 16);
                r[1] = Math.floor(r[1] / 16);
                // list all of the chunks inside it
                for (let x = l[0]; x <= r[0]; x++) 
                    for (let z = l[1]; z <= r[1]; z++)
                        cur.chunks.push({ x: x, z: z }); // push chunk info
            } else
                cur[l1] = prompt(TEMPLATE[l1]); // prompt question

            if (l1 == 'id') {
                // check if input ID is empty to exit
                if (!cur.id) EXIT = true;
                else if (cur.id == '.') {
                    // if user ask for random-generated
                    cur.id = '';
                    for (let _ = 0; _ < 6; _++) 
                        cur.id += ALLOW_CHAR[Math.floor(Math.random() * ALLOW_CHAR.length)];
                }

                // clean id to upper case
                cur.id = cur.id.toUpperCase();
                // check id conflict
                for (const build of REGISTRY)
                    if (cur.id == build.id) {
                        EXIT = true; 
                        alert('Conflict ID ' + cur.id);
                    }
            } else if (l1 == 'address') {
                cur[l1] = cur[l1].toUpperCase();
                // replace road type capitalization
                for (let type of ROAD_TYPE)
                    cur[l1] = cur[l1].replace(' ' + type.toUpperCase(), ' ' + type);
            }
            if (EXIT) break;
        }
        if (cur.id) REGISTRY.push(cur); // if the curent build is available to add
        // if there is exit request
        if (EXIT) {
            const reg = 'let REGISTRY = ' + JSON.stringify(REGISTRY, null, '    ');
            if (confirm('Do you want to download the registry?')) {
                // create registry as a file then download it
                const link = document.createElement("a");
                const file = new Blob([reg], { type: 'text/plain' });
                link.href = URL.createObjectURL(file);
                link.download = "registry.js";
                link.click();
                URL.revokeObjectURL(link.href);
            } else
                document.getElementById('out').innerHTML = reg; // just in case of misclick
            break; // either way, exit the loop
        };
    }
</script>